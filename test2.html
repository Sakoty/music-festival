<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Motion Sound â€” å®Œå…¨çµ±åˆç‰ˆï¼ˆå­¦ç¿’æ”¹å–„ï¼‰</title>
<style>
:root{--bg:#fff;--card:#f8f9fb;--muted:#666;--accent:#0b84ff}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,"Noto Sans JP";margin:0;background:var(--bg);color:#111}
.wrap{max-width:920px;margin:18px auto;padding:18px}
h1{font-size:20px;margin:0 0 12px}
.grid{display:grid;grid-template-columns:1fr 360px;gap:14px}
.card{background:#fff;border:1px solid #e6e9ef;padding:14px;border-radius:10px;box-shadow:0 2px 6px rgba(12,12,12,0.03)}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
button{background:var(--accent);color:white;border:0;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
button.ghost{background:#eee;color:#222}
label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
input[type=range]{width:100%}
select,input[type=text],input[type=file]{width:100%;padding:8px;border-radius:8px;border:1px solid #ddd}
small{color:var(--muted)}
#log{height:120px;overflow:auto;background:#0f1724;color:#d1d5db;padding:8px;border-radius:8px;font-family:monospace;font-size:12px}
ul.list{list-style:none;padding:0;margin:8px 0}
ul.list li{padding:8px;border-bottom:1px solid #f1f3f5;display:flex;justify-content:space-between;gap:8px;align-items:center}
.muted{color:var(--muted)}
canvas#viz{width:100%;height:120px;background:#0b1220;border-radius:6px}
.smallbtn{background:#fff;border:1px solid #e6e9ef;padding:6px 8px;color:#222;border-radius:6px}
.footer{margin-top:12px;font-size:12px;color:var(--muted)}

/* --- æ–°UI: å­¦ç¿’çŠ¶æ…‹è¡¨ç¤º --- */
.learn-ui { margin-top:8px; display:flex; gap:8px; align-items:center; }
.progress { height:10px; background:#eee; border-radius:6px; overflow:hidden; width:100%; }
.progress > i { display:block; height:100%; width:0%; background:var(--accent); transition:width 0.12s linear; }
.badge { padding:4px 8px; border-radius:8px; background:#f1f5f9; color:#111; font-size:13px; }
.pattern-preview { width:100%; height:56px; background:#081017; border-radius:6px; margin-top:8px; }
.pattern-meta { font-size:12px; color:var(--muted); margin-top:6px; }
</style>
</head>
<body>
<div class="wrap">
<h1>Motion Sound â€” å®Œå…¨çµ±åˆç‰ˆï¼ˆå­¦ç¿’æ”¹å–„ï¼‰</h1>
<div class="grid">
  <div class="card">
    <h3>æº–å‚™ & è¨±å¯</h3>
    <div class="controls">
      <button id="initBtn">é–‹å§‹ï¼ˆã‚¿ãƒƒãƒ—ã—ã¦è¨±å¯ï¼‰</button>
      <button id="startDetectBtn" class="ghost" disabled>æ¤œçŸ¥ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      <button id="stopDetectBtn" class="ghost" disabled>æ¤œçŸ¥åœæ­¢</button>
    </div>
    <p class="muted">iPhone ã¯å¿…ãšã‚¿ãƒƒãƒ—å†…ã§è¨±å¯ãŒå¿…è¦ã€‚</p>

    <hr/>

    <h3>éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆè¤‡æ•°å¯ / ãƒ­ãƒ¼ã‚«ãƒ«ï¼‰</h3>
    <input id="fileInput" type="file" accept="audio/*" multiple>
    <label>å¤–éƒ¨éŸ³æºURL<input id="urlInput" type="text" placeholder="ä¾‹: https://.../sound.mp3"></label>
    <button id="addUrlBtn">URLç™»éŒ²</button>

    <select id="motionSelect">
      <option value="shake">å¼·ã„ã‚·ã‚§ã‚¤ã‚¯</option>
      <option value="x">å·¦å³(X)</option>
      <option value="y">ä¸Šä¸‹(Y)</option>
      <option value="z">å‰å¾Œ(Z)</option>
      <option value="learned">å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³</option>
    </select>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="assignFiles">ç™»éŒ²</button>
      <button id="clearMotionSounds" class="ghost">é¸æŠãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®éŸ³ã‚’ã‚¯ãƒªã‚¢</button>
    </div>
    <p id="assignMsg" class="muted"></p>

    <hr/>

    <h3>ç™»éŒ²éŸ³ä¸€è¦§</h3>
    <ul id="soundLists" class="list"></ul>

    <hr/>

    <h3>æ„Ÿåº¦ãƒ»è¨­å®š</h3>
    <label>ã‚·ã‚§ã‚¤ã‚¯é–¾å€¤<input id="shakeThresh" type="range" min="1.5" max="10" step="0.1" value="4"></label>
    <label>è»¸é–¾å€¤<input id="axisThresh" type="range" min="0.5" max="6" step="0.1" value="2"></label>
    <label>å­¦ç¿’ãƒãƒƒãƒé–¾å€¤<input id="matchThresh" type="range" min="0.1" max="10" step="0.1" value="2.5"></label>
    <label>ãƒˆãƒªã‚¬ãƒ¼å†·å´(ms)<input id="cooldown" type="range" min="200" max="5000" step="100" value="800"></label>
    <label>ãƒã‚¹ã‚¿ãƒ¼éŸ³é‡<input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.8"></label>

    <hr/>

    <h3>ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å­¦ç¿’</h3>
    <label>ãƒ‘ã‚¿ãƒ¼ãƒ³å <input id="patternName" type="text" placeholder="ä¾‹: 2å›ç¸¦ã«æŒ¯ã‚‹"></label>
    <label>å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ç”¨ã®éŸ³ 
      <select id="learnSoundSelect"></select>
    </label>

    <div class="learn-ui">
      <button id="startLearn">å­¦ç¿’é–‹å§‹ï¼ˆ3ç§’ï¼‰</button>
      <div class="progress" title="å­¦ç¿’é€²æ—"><i id="learnProgress"></i></div>
      <div class="badge" id="learnState">å¾…æ©Ÿ</div>
    </div>

    <div class="pattern-meta" id="learnInfo">è¨˜éŒ²æ•°: 0</div>
    <canvas id="patternPreview" class="pattern-preview"></canvas>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="savePattern" class="ghost">ä¿å­˜</button>
      <button id="testPattern" class="ghost">ãƒ†ã‚¹ãƒˆå†ç”Ÿ</button>
    </div>

    <hr/>
    <h3>ä¿å­˜ãƒ‘ã‚¿ãƒ¼ãƒ³</h3>
    <ul id="patternList" class="list"></ul>
  </div>

  <div class="card">
    <h3>çŠ¶æ…‹</h3>
    <div id="status">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: å¾…æ©Ÿä¸­</div>
    <h4>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¯è¦–åŒ–</h4>
    <canvas id="viz"></canvas>
    <h4>ãƒ­ã‚°</h4>
    <div id="log"></div>
    <div class="footer">ãƒ’ãƒ³ãƒˆ: iPhoneã¯ç”»é¢ã‚¿ãƒƒãƒ—å†…ã§ã€Œé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>
  </div>
</div>
</div>

<script>
/* =========================
   åŸºæœ¬ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª / UI åˆæœŸ
   ========================= */
let audioCtx=null;
const master={gainNode:null,vol:0.8};
const soundMap={shake:[],x:[],y:[],z:[],learned:[]};

function initAudioIfNeeded(){
  if(!audioCtx){
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    master.gainNode=audioCtx.createGain();
    master.gainNode.gain.value=master.vol;
    master.gainNode.connect(audioCtx.destination);
    // resume on first user gesture
    document.addEventListener('click', ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); }, {once:true});
    document.addEventListener('touchstart', ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); }, {once:true});
    log('AudioContext åˆæœŸåŒ–');
  }
}
function decodeAudioSafe(arrayBuffer){
  initAudioIfNeeded();
  return new Promise((resolve,reject)=>{
    try{
      const p = audioCtx.decodeAudioData(arrayBuffer.slice(0),
        (buf)=>resolve(buf),
        (err)=>reject(err)
      );
      // in some browsers decodeAudioData returns a promise
      if(p && typeof p.then === 'function') p.then(resolve).catch(reject);
    }catch(e){ reject(e); }
  });
}
function playBuffer(buf){
  if(!buf) { console.warn('playBuffer: buf is null'); return; }
  if(audioCtx.state==='suspended') audioCtx.resume();
  const src=audioCtx.createBufferSource();
  src.buffer=buf;
  src.connect(master.gainNode);
  try{ src.start(); }catch(e){ console.error('start failed', e); }
}
function setMasterVol(v){ master.vol=v; if(master.gainNode) master.gainNode.gain.value=v; }

/* =========================
   ã‚µã‚¦ãƒ³ãƒ‰ç™»éŒ²: ãƒ­ãƒ¼ã‚«ãƒ« / URL
   ========================= */
document.getElementById('assignFiles').addEventListener('click', async ()=>{
  const files=Array.from(document.getElementById('fileInput').files || []);
  const motion=document.getElementById('motionSelect').value;
  if(files.length===0){ alert('éŸ³ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ'); return; }
  initAudioIfNeeded();
  for(const f of files){
    try{
      const ab = await f.arrayBuffer();
      const buf = await decodeAudioSafe(ab);
      if(!buf) { log(`decodeå¤±æ•—: ${f.name}`); continue; }
      soundMap[motion].push({name:f.name, buf});
      log(`ç™»éŒ²: ${f.name} -> ${motion}`);
    }catch(e){ console.error(e); log(`ç™»éŒ²å¤±æ•—: ${f.name}`); }
  }
  refreshSoundLists();
  refreshLearnSoundSelect();
});

document.getElementById('addUrlBtn').addEventListener('click', async ()=>{
  const url = document.getElementById('urlInput').value.trim();
  const motion = document.getElementById('motionSelect').value;
  if(!url){ alert('URLå…¥åŠ›'); return; }
  initAudioIfNeeded();
  try{
    const res = await fetch(url, { mode: 'cors' });
    if(!res.ok) throw new Error('fetch failed: '+res.status);
    const ab = await res.arrayBuffer();
    const buf = await decodeAudioSafe(ab);
    if(!buf) { log('URL decodeå¤±æ•—: '+url); return; }
    const name = url.split('/').pop() || url;
    soundMap[motion].push({name, buf});
    log(`å¤–éƒ¨URLç™»éŒ²: ${name} -> ${motion}`);
  }catch(e){ console.error(e); log(`URLç™»éŒ²å¤±æ•—: ${url}`); alert('URLã‹ã‚‰ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆCORS/å½¢å¼ã‚’ç¢ºèªï¼‰'); }
  refreshSoundLists();
  refreshLearnSoundSelect();
});

document.getElementById('clearMotionSounds').addEventListener('click', ()=>{
  const motion=document.getElementById('motionSelect').value;
  if(!confirm(motion+' ã®éŸ³ã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) return;
  soundMap[motion]=[];
  refreshSoundLists();
  refreshLearnSoundSelect();
  log(`${motion} ã‚¯ãƒªã‚¢`);
});

function refreshSoundLists(){
  const ul=document.getElementById('soundLists'); ul.innerHTML='';
  for(const k in soundMap){
    if(soundMap[k].length===0) continue;
    const li=document.createElement('li');
    const left=document.createElement('div'); left.innerHTML=`<strong>${k}</strong> (${soundMap[k].length})`;
    const right=document.createElement('div');
    soundMap[k].forEach((s,i)=>{
      const play=document.createElement('button'); play.className='smallbtn'; play.textContent='â–¶';
      play.addEventListener('click', ()=> playBuffer(s.buf) );
      const rm=document.createElement('button'); rm.className='smallbtn'; rm.textContent='âœ•';
      rm.addEventListener('click', ()=> { soundMap[k].splice(i,1); refreshSoundLists(); refreshLearnSoundSelect(); });
      const span=document.createElement('span'); span.style.marginLeft='6px'; span.textContent=s.name;
      right.appendChild(play); right.appendChild(rm); right.appendChild(span);
    });
    li.appendChild(left); li.appendChild(right); ul.appendChild(li);
  }
}

/* =========================
   å­¦ç¿’ãƒ­ã‚¸ãƒƒã‚¯æ”¹å–„ & UI
   ========================= */
let currentLearn = [];        // ç”Ÿãƒ‡ãƒ¼ã‚¿ï¼ˆå­¦ç¿’ä¸­ã« push ã•ã‚Œã‚‹ï¼‰
let isLearning = false;
let learnStartAt = 0;
let lastTriggeredAt = {};

// UI elems for learning progress and preview
const learnProgressEl = document.getElementById('learnProgress');
const learnStateEl = document.getElementById('learnState');
const learnInfoEl = document.getElementById('learnInfo');
const patternPreviewCanvas = document.getElementById('patternPreview');
const pctx = patternPreviewCanvas.getContext('2d');

// handle start learn with clear visual countdown & disable button while recording
document.getElementById('startLearn').addEventListener('click', ()=>{
  if(isLearning) return;
  currentLearn = [];
  isLearning = true;
  learnStartAt = Date.now();
  document.getElementById('startLearn').disabled = true;
  learnStateEl.textContent = 'éŒ²éŸ³ä¸­';
  learnStateEl.style.background = '#ffe8b2';
  learnStateEl.style.color = '#111';
  updateLearnProgress(0);
  log('å­¦ç¿’é–‹å§‹ â€” 3ç§’é–“è¨˜éŒ²ã—ã¾ã™');
  // progress animation (3s)
  const duration = 3000;
  const tick = 50;
  let elapsed = 0;
  const iv = setInterval(()=>{
    elapsed += tick;
    const pct = Math.min(1, elapsed / duration) * 100;
    updateLearnProgress(pct);
    if(elapsed >= duration){
      clearInterval(iv);
      isLearning = false;
      learnStateEl.textContent = 'éŒ²éŸ³å®Œäº†';
      learnStateEl.style.background = '#d3f9d8';
      document.getElementById('startLearn').disabled = false;
      log(`å­¦ç¿’çµ‚äº† â€” è¨˜éŒ²ç‚¹æ•°: ${currentLearn.length}`);
      updateLearnInfo();
      drawLearnPreview(); // show waveform for recorded sample
    }
  }, tick);
});

// helper to update progress bar
function updateLearnProgress(pct){
  learnProgressEl.style.width = `${pct}%`;
  // small text badge
  learnStateEl.textContent = pct < 100 ? `éŒ²éŸ³ä¸­ ${Math.round(pct)}%` : 'éŒ²éŸ³å®Œäº†';
}

// update counter text
function updateLearnInfo(){
  learnInfoEl.textContent = `è¨˜éŒ²æ•°: ${currentLearn.length} ï¼ˆç´„ ${Math.round(currentLearn.length/60)} ç§’ï¼‰`;
}

// draw small preview of last recorded pattern
function drawLearnPreview(arr){
  const a = arr || currentLearn;
  const w = patternPreviewCanvas.width = patternPreviewCanvas.clientWidth * devicePixelRatio;
  const h = patternPreviewCanvas.height = patternPreviewCanvas.clientHeight * devicePixelRatio;
  pctx.clearRect(0,0,w,h);
  pctx.fillStyle = '#081017';
  pctx.fillRect(0,0,w,h);
  if(!a || a.length === 0) return;
  pctx.lineWidth = 1.5 * devicePixelRatio;
  pctx.strokeStyle = '#6ee7b7';
  pctx.beginPath();
  const N = a.length;
  for(let i=0;i<N;i++){
    const x = i * w / (N-1);
    const y = h - Math.min(1.0, a[i]/20) * h;
    if(i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y);
  }
  pctx.stroke();
}

/* save pattern button: store data (resampled) + reference to chosen sound */
document.getElementById('savePattern').addEventListener('click', ()=>{
  const name = document.getElementById('patternName').value.trim();
  if(!name){ alert('ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  if(currentLearn.length < 12){ alert('å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãŒçŸ­ã™ãã¾ã™ã€‚å­¦ç¿’ã‚’ã‚„ã‚Šç›´ã—ã¦ãã ã•ã„ã€‚'); return; }
  const sel = document.getElementById('learnSoundSelect');
  const soundRef = sel.value;
  if(!soundRef){ alert('å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç´ã¥ã‘ã‚‹éŸ³ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }
  const [motion, idx] = soundRef.split('|');
  const bufRef = soundMap[motion] && soundMap[motion][Number(idx)] ? soundMap[motion][Number(idx)].buf : null;
  // normalize/resample to fixed length
  const norm = resample(currentLearn, 60);
  const saved = JSON.parse(localStorage.getItem('motionPatterns') || '[]');
  saved.push({ name, data: norm, sound: { motion, idx: Number(idx) }, created: Date.now(), rawLen: currentLearn.length });
  localStorage.setItem('motionPatterns', JSON.stringify(saved));
  refreshPatternList();
  log(`ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿å­˜: ${name} (len=${currentLearn.length})`);
});

// test pattern: play selected learnSound
document.getElementById('testPattern').addEventListener('click', ()=>{
  const sel = document.getElementById('learnSoundSelect');
  const soundRef = sel.value;
  if(!soundRef){ alert('éŸ³ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }
  const [motion, idx] = soundRef.split('|');
  const entry = soundMap[motion] && soundMap[motion][Number(idx)];
  if(entry && entry.buf) playBuffer(entry.buf);
});

/* refresh learn sound select dropdown */
function refreshLearnSoundSelect(){
  const sel = document.getElementById('learnSoundSelect');
  const prev = sel.value;
  sel.innerHTML = '<option value="">-- é¸æŠ --</option>';
  for(const m in soundMap){
    soundMap[m].forEach((s,i)=>{
      const opt = document.createElement('option');
      opt.value = m + '|' + i;
      opt.textContent = `${s.name} (${m})`;
      sel.appendChild(opt);
    });
  }
  if(prev) sel.value = prev;
}

/* render saved patterns with metadata & playback */
function refreshPatternList(){
  const ul = document.getElementById('patternList'); ul.innerHTML = '';
  const saved = JSON.parse(localStorage.getItem('motionPatterns') || '[]');
  saved.forEach((p, i)=>{
    const li = document.createElement('li');
    const left = document.createElement('div');
    left.innerHTML = `<strong>${p.name}</strong><br><small class="muted">len:${p.rawLen || p.data.length} saved:${new Date(p.created||0).toLocaleString()}</small>`;
    const right = document.createElement('div');
    const playBtn = document.createElement('button'); playBtn.className='smallbtn'; playBtn.textContent='â–¶';
    playBtn.title = 'ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç´ã¥ãéŸ³ã‚’å†ç”Ÿ';
    playBtn.addEventListener('click', ()=> playPatternSound(p));
    const previewBtn = document.createElement('button'); previewBtn.className='smallbtn'; previewBtn.textContent='ğŸ“ˆ';
    previewBtn.title = 'ãƒ‘ã‚¿ãƒ¼ãƒ³æ³¢å½¢ã‚’è¡¨ç¤º';
    previewBtn.addEventListener('click', ()=> drawLearnPreview(p.data));
    const delBtn = document.createElement('button'); delBtn.className='smallbtn'; delBtn.textContent='âœ•';
    delBtn.addEventListener('click', ()=>{
      if(!confirm('å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
      saved.splice(i,1); localStorage.setItem('motionPatterns', JSON.stringify(saved)); refreshPatternList();
    });
    right.appendChild(playBtn); right.appendChild(previewBtn); right.appendChild(delBtn);
    li.appendChild(left); li.appendChild(right);
    ul.appendChild(li);
  });
}

/* play sound associated with pattern (if exists) */
function playPatternSound(p){
  if(!p || !p.sound) { log('pattern sound missing'); return; }
  const { motion, idx } = p.sound;
  const arr = soundMap[motion] || [];
  const entry = arr[Number(idx)];
  if(entry && entry.buf) playBuffer(entry.buf);
  else log('ç´ã¥ã‘ã‚‰ã‚ŒãŸéŸ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
}

/* =========================
   DTW / resample (unchanged core)
   ========================= */
function dtwDistance(a,b){
  const n=a.length, m=b.length; if(n===0||m===0) return Infinity;
  const INF=1e9;
  const D = new Array(n+1);
  for(let i=0;i<=n;i++){ D[i] = new Array(m+1).fill(INF); }
  D[0][0]=0;
  for(let i=1;i<=n;i++){
    for(let j=1;j<=m;j++){
      const cost = Math.abs(a[i-1] - b[j-1]);
      D[i][j] = cost + Math.min(D[i-1][j], D[i][j-1], D[i-1][j-1]);
    }
  }
  return D[n][m] / (n+m);
}
function resample(arr, targetLen){
  if(arr.length === targetLen) return arr.slice();
  if(arr.length === 0) return new Array(targetLen).fill(0);
  const out = new Array(targetLen);
  for(let i=0;i<targetLen;i++){
    const t = i * (arr.length-1) / (targetLen-1);
    const lo = Math.floor(t), hi = Math.ceil(t);
    out[i] = lo === hi ? arr[lo] : arr[lo] * (hi - t) + arr[hi] * (t - lo);
  }
  return out;
}

/* =========================
   å¯è¦–åŒ–ï¼ˆãƒ¡ã‚¤ãƒ³ + ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰
   ========================= */
const viz = document.getElementById('viz'); const vctx = viz.getContext('2d');
let vizBuffer = [];
window.addEventListener('resize', drawViz);
function drawViz(){
  viz.width = viz.clientWidth * devicePixelRatio; viz.height = viz.clientHeight * devicePixelRatio;
  vctx.clearRect(0,0,viz.width,viz.height);
  vctx.fillStyle = '#07121a'; vctx.fillRect(0,0,viz.width,viz.height);
  if(vizBuffer.length === 0) return;
  vctx.lineWidth = 2 * devicePixelRatio; vctx.strokeStyle = '#0bffb3'; vctx.beginPath();
  const N = vizBuffer.length;
  for(let i=0;i<N;i++){
    const x = i * viz.width / (N-1);
    const y = viz.height - Math.min(1.0, vizBuffer[i]/20) * viz.height;
    if(i===0) vctx.moveTo(x,y); else vctx.lineTo(x,y);
  }
  vctx.stroke();
}

/* =========================
   DeviceMotion æ¤œçŸ¥ï¼ˆä¿®æ­£ï¼‰
   - å­¦ç¿’ä¸­ã¯ currentLearn ã« pushï¼ˆä¸€å®šé–“éš”ã§ï¼‰ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®‰å®šåŒ–
   - æ¤œå‡ºãƒ«ãƒ¼ãƒ—ã§ saved ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨æ¯”è¼ƒã—ã¦ç™ºç«
   ========================= */
let sampleAccum = 0;
let lastSampleTime = 0;
const SAMPLE_INTERVAL_MS = 25; // å­¦ç¿’æ™‚ã«å–ã‚Šè¾¼ã‚€é–“éš”ï¼ˆmsï¼‰

window.addEventListener('devicemotion', (ev)=>{
  const acc = ev.accelerationIncludingGravity || ev.acceleration;
  if(!acc) return;
  const ax = acc.x || 0, ay = acc.y || 0, az = acc.z || 0;
  const total = Math.sqrt(ax*ax + ay*ay + az*az);

  // viz buffer for display (short)
  vizBuffer.push(total);
  if(vizBuffer.length > 240) vizBuffer.shift();
  drawViz();

  // sample at fixed interval when learning
  const now = Date.now();
  if(isLearning){
    if(now - lastSampleTime >= SAMPLE_INTERVAL_MS){
      currentLearn.push(total);
      lastSampleTime = now;
      updateLearnInfo();
    }
  }

  // detection only when detection is enabled
  if(document.getElementById('startDetectBtn').disabled === false){
    // not started
    return;
  }

  const cooldownMs = Number(document.getElementById('cooldown').value);
  const shakeThreshold = Number(document.getElementById('shakeThresh').value);
  const axisThreshold = Number(document.getElementById('axisThresh').value);
  const matchThresh = Number(document.getElementById('matchThresh').value);

  // å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¤å®šï¼ˆæœ€è¿‘ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ resample ã—ã¦æ¯”è¼ƒï¼‰
  const saved = JSON.parse(localStorage.getItem('motionPatterns') || '[]');
  if(saved.length > 0){
    const candidate = resample(vizBuffer.slice(-240), 60);
    let best = null, bestScore = Infinity;
    for(const p of saved){
      const score = dtwDistance(candidate, p.data);
      if(score < bestScore){ bestScore = score; best = p; }
    }
    if(best && bestScore < matchThresh){
      if(now - (lastTriggeredAt['learned']||0) > cooldownMs){
        lastTriggeredAt['learned'] = now;
        status(`å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º: ${best.name}`);
        playPatternSound(best);
        log(`å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³: ${best.name} ãƒˆãƒªã‚¬ãƒ¼ (score ${bestScore.toFixed(2)})`);
      }
    }
  }

  // ã‚·ã‚§ã‚¤ã‚¯åˆ¤å®šï¼ˆå¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
  if(total > shakeThreshold && now - (lastTriggeredAt['shake']||0) > cooldownMs){
    lastTriggeredAt['shake'] = now;
    if(soundMap.shake.length > 0) {
      const idx = Math.floor(Math.random() * soundMap.shake.length);
      playBuffer(soundMap.shake[idx].buf);
    }
    log('Shake!');
  }

  // è»¸åˆ¤å®šï¼ˆX/Y/Zï¼‰
  if(Math.abs(ax) > axisThreshold && now - (lastTriggeredAt['x']||0) > cooldownMs){ lastTriggeredAt['x'] = now; status('Xè»¸å‹•ä½œ'); if(soundMap.x.length) playBuffer(soundMap.x[Math.floor(Math.random()*soundMap.x.length)].buf); log('Xãƒˆãƒªã‚¬ãƒ¼'); }
  if(Math.abs(ay) > axisThreshold && now - (lastTriggeredAt['y']||0) > cooldownMs){ lastTriggeredAt['y'] = now; status('Yè»¸å‹•ä½œ'); if(soundMap.y.length) playBuffer(soundMap.y[Math.floor(Math.random()*soundMap.y.length)].buf); log('Yãƒˆãƒªã‚¬ãƒ¼'); }
  if(Math.abs(az) > axisThreshold && now - (lastTriggeredAt['z']||0) > cooldownMs){ lastTriggeredAt['z'] = now; status('Zè»¸å‹•ä½œ'); if(soundMap.z.length) playBuffer(soundMap.z[Math.floor(Math.random()*soundMap.z.length)].buf); log('Zãƒˆãƒªã‚¬ãƒ¼'); }
});

/* =========================
   è¨±å¯ãƒœã‚¿ãƒ³ / æ¤œçŸ¥é–‹å§‹åœæ­¢
   - initBtn ã¯ iOS ã® requestPermission ã‚’å‘¼ã³å‡ºã™ï¼ˆã‚¿ãƒƒãƒ—å†…ï¼‰
   ========================= */
document.getElementById('initBtn').addEventListener('click', async ()=>{
  initAudioIfNeeded();
  // request motion permission on iOS Safari
  if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
    try{
      const res = await DeviceMotionEvent.requestPermission();
      if(res === 'granted'){
        status('ã‚»ãƒ³ã‚µãƒ¼è¨±å¯: granted');
        document.getElementById('startDetectBtn').disabled = false;
        log('Motion granted');
      } else {
        status('ã‚»ãƒ³ã‚µãƒ¼è¨±å¯: denied');
        alert('å‹•ãã‚»ãƒ³ã‚µãƒ¼ã®è¨±å¯ãŒå¿…è¦ã§ã™');
        log('Motion denied');
      }
    } catch(e){
      console.error(e);
      alert('è¨±å¯ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      log('requestPermission error');
    }
  } else {
    document.getElementById('startDetectBtn').disabled = false;
    status('Motion API OK (request not required)');
    log('Motion API: OK');
  }
});

document.getElementById('startDetectBtn').addEventListener('click', ()=>{
  document.getElementById('startDetectBtn').disabled = true;
  document.getElementById('stopDetectBtn').disabled = false;
  status('æ¤œçŸ¥é–‹å§‹');
  log('æ¤œçŸ¥ã‚’é–‹å§‹');
  // When detection starts we set a flag by disabling start button (used above in devicemotion)
});

document.getElementById('stopDetectBtn').addEventListener('click', ()=>{
  document.getElementById('startDetectBtn').disabled = false;
  document.getElementById('stopDetectBtn').disabled = true;
  status('åœæ­¢');
  log('æ¤œçŸ¥ã‚’åœæ­¢');
});

/* =========================
   å°ã•ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ UI/ãƒ­ã‚°
   ========================= */
function status(txt){ document.getElementById('status').textContent = 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ' + txt; }
function log(txt){ const l = document.getElementById('log'); const t = new Date().toLocaleTimeString(); l.innerHTML = `[${t}] ${txt}\n` + l.innerHTML; }

/* Initial refresh */
window.addEventListener('load', ()=>{
  refreshSoundLists(); refreshLearnSoundSelect(); refreshPatternList(); drawViz(); drawLearnPreview();
});

/* ===== è¿½åŠ ãƒ•ãƒ©ã‚° ===== */
let isDetecting = false;

/* ===== DeviceMotionï¼ˆå­¦ç¿’ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿æ¤œçŸ¥ï¼‰ ===== */
window.addEventListener('devicemotion', (ev)=>{
  const acc = ev.accelerationIncludingGravity || ev.acceleration;
  if(!acc) return;

  const ax = acc.x || 0, ay = acc.y || 0, az = acc.z || 0;
  const total = Math.sqrt(ax*ax + ay*ay + az*az);

  /* å¯è¦–åŒ– */
  vizBuffer.push(total);
  if(vizBuffer.length > 240) vizBuffer.shift();
  drawViz();

  const now = Date.now();

  /* å­¦ç¿’ä¸­ã®è¨˜éŒ² */
  if(isLearning){
    if(now - lastSampleTime >= SAMPLE_INTERVAL_MS){
      currentLearn.push(total);
      lastSampleTime = now;
      updateLearnInfo();
    }
    return;
  }

  /* ===== æ¤œçŸ¥OFFãªã‚‰ä½•ã‚‚ã—ãªã„ ===== */
  if(!isDetecting) return;

  const cooldownMs = Number(document.getElementById('cooldown').value);
  const matchThresh = Number(document.getElementById('matchThresh').value);

  /* ===== å­¦ç¿’ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿åˆ¤å®š ===== */
  const saved = JSON.parse(localStorage.getItem('motionPatterns') || '[]');
  if(saved.length === 0) return;

  const candidate = resample(vizBuffer.slice(-240), 60);

  let best = null;
  let bestScore = Infinity;

  for(const p of saved){
    const score = dtwDistance(candidate, p.data);
    if(score < bestScore){
      bestScore = score;
      best = p;
    }
  }

  if(best && bestScore < matchThresh){
    if(now - (lastTriggeredAt['learned']||0) > cooldownMs){
      lastTriggeredAt['learned'] = now;
      status(`å­¦ç¿’ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ¤œå‡º: ${best.name}`);
      playPatternSound(best);
      log(`æ¤œå‡º: ${best.name} (score=${bestScore.toFixed(2)})`);
    }
  }
});

/* ===== æ¤œçŸ¥é–‹å§‹/åœæ­¢ ===== */
document.getElementById('startDetectBtn').addEventListener('click', ()=>{
  isDetecting = true;
  startDetectBtn.disabled = true;
  stopDetectBtn.disabled = false;
  status('æ¤œçŸ¥ä¸­ï¼ˆå­¦ç¿’ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿ï¼‰');
  log('æ¤œçŸ¥ON');
});

document.getElementById('stopDetectBtn').addEventListener('click', ()=>{
  isDetecting = false;
  startDetectBtn.disabled = false;
  stopDetectBtn.disabled = true;
  status('åœæ­¢');
  log('æ¤œçŸ¥OFF');
});
</script>
</body>
</html>
